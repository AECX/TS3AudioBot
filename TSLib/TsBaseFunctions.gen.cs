// TSLib - A free TeamSpeak 3 and 5 client library
// Copyright (C) 2017  TSLib contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />















using System;
using System.Threading.Tasks;
using TSLib.Commands;
using TSLib.Messages;

#nullable enable
namespace TSLib
{
	partial class TsBaseFunctions
	{

		/// <summary>
		/// Sends a TS-command.
		/// 
		/// 
		/// </summary>
		/// <param name="command">The command name.</param>
		/// <param name="parameter">The parameters to be added to this command.
		/// See <see cref="CommandParameter"/>, <see cref="CommandOption"/> or <see cref="CommandMultiParameter"/> for more information.</param>
		/// 
		/// 
		public Task<R<ResponseDictionary[], CommandError>> Send(string command, params ICommandPart[] parameter)
			=> Send<ResponseDictionary>(new TsCommand(command, parameter));

		/// <summary>
		/// Sends a TS-command.
		/// 
		/// 
		/// </summary>
		/// <param name="command">The command name.</param>
		/// <param name="parameter">The parameters to be added to this command.
		/// See <see cref="CommandParameter"/>, <see cref="CommandOption"/> or <see cref="CommandMultiParameter"/> for more information.</param>
		/// 
		/// <returns>Returns an enumeration of the deserialized and split up in <see cref="T"/> objects data.</returns>
		public Task<R<T[], CommandError>> Send<T>(string command, params ICommandPart[] parameter) where T : IResponse, new()
			=> Send<T>(new TsCommand(command, parameter));

		/// <summary>
		/// Sends a TS-command.
		/// 
		/// The response (if any) is not deserialized and is discarded.
		/// </summary>
		/// <param name="command">The command name.</param>
		/// <param name="parameter">The parameters to be added to this command.
		/// See <see cref="CommandParameter"/>, <see cref="CommandOption"/> or <see cref="CommandMultiParameter"/> for more information.</param>
		/// 
		/// 
		public Task<E<CommandError>> SendVoid(string command, params ICommandPart[] parameter)
			=> Send<ResponseVoid>(new TsCommand(command, parameter)).ContinueWith(t => t.Result.OnlyError());

		/// <summary>
		/// Sends a TS-command.
		/// 
		/// The response (if any) is not deserialized and is discarded.
		/// </summary>
		/// <param name="command">The command name.</param>
		/// <param name="parameter">The parameters to be added to this command.
		/// See <see cref="CommandParameter"/>, <see cref="CommandOption"/> or <see cref="CommandMultiParameter"/> for more information.</param>
		/// 
		/// 
		public Task<E<CommandError>> SendVoid(TsCommand com)
			=> Send<ResponseVoid>(com).ContinueWith(t => t.Result.OnlyError());

		/// <summary>
		/// Sends a TS-command.
		/// This will send a normal query-command when connected via query client. When connected as a full client the first specified notification is used as the response.
		/// 
		/// </summary>
		/// <param name="command">The command name.</param>
		/// <param name="parameter">The parameters to be added to this command.
		/// See <see cref="CommandParameter"/>, <see cref="CommandOption"/> or <see cref="CommandMultiParameter"/> for more information.</param>
		/// <param name="type">The notification type to wait for and serialize to when called from the full client.</param>
		/// 
		public Task<R<ResponseDictionary[], CommandError>> SendHybrid(string command, NotificationType type, params ICommandPart[] parameter)
			=> SendHybrid<ResponseDictionary>(new TsCommand(command, parameter), type);

		/// <summary>
		/// Sends a TS-command.
		/// This will send a normal query-command when connected via query client. When connected as a full client the first specified notification is used as the response.
		/// 
		/// </summary>
		/// <param name="command">The command name.</param>
		/// <param name="parameter">The parameters to be added to this command.
		/// See <see cref="CommandParameter"/>, <see cref="CommandOption"/> or <see cref="CommandMultiParameter"/> for more information.</param>
		/// <param name="type">The notification type to wait for and serialize to when called from the full client.</param>
		/// <returns>Returns an enumeration of the deserialized and split up in <see cref="T"/> objects data.</returns>
		public Task<R<T[], CommandError>> SendHybrid<T>(string command, NotificationType type, params ICommandPart[] parameter) where T : class, IResponse, new()
			=> SendHybrid<T>(new TsCommand(command, parameter), type);


#pragma warning disable CS0067

		public virtual event NotifyEventHandler<ChannelChanged>? OnChannelChanged;
		public virtual event EventHandler<ChannelChanged>? OnEachChannelChanged;
		public virtual event NotifyEventHandler<ChannelCreated>? OnChannelCreated;
		public virtual event EventHandler<ChannelCreated>? OnEachChannelCreated;
		public virtual event NotifyEventHandler<ChannelDeleted>? OnChannelDeleted;
		public virtual event EventHandler<ChannelDeleted>? OnEachChannelDeleted;
		public virtual event NotifyEventHandler<ChannelEdited>? OnChannelEdited;
		public virtual event EventHandler<ChannelEdited>? OnEachChannelEdited;
		public virtual event NotifyEventHandler<ChannelMoved>? OnChannelMoved;
		public virtual event EventHandler<ChannelMoved>? OnEachChannelMoved;
		public virtual event NotifyEventHandler<ChannelPasswordChanged>? OnChannelPasswordChanged;
		public virtual event EventHandler<ChannelPasswordChanged>? OnEachChannelPasswordChanged;
		public virtual event NotifyEventHandler<ClientEnterView>? OnClientEnterView;
		public virtual event EventHandler<ClientEnterView>? OnEachClientEnterView;
		public virtual event NotifyEventHandler<ClientLeftView>? OnClientLeftView;
		public virtual event EventHandler<ClientLeftView>? OnEachClientLeftView;
		public virtual event NotifyEventHandler<ClientMoved>? OnClientMoved;
		public virtual event EventHandler<ClientMoved>? OnEachClientMoved;
		public virtual event NotifyEventHandler<ServerEdited>? OnServerEdited;
		public virtual event EventHandler<ServerEdited>? OnEachServerEdited;
		public virtual event NotifyEventHandler<TextMessage>? OnTextMessage;
		public virtual event EventHandler<TextMessage>? OnEachTextMessage;
		public virtual event NotifyEventHandler<TokenUsed>? OnTokenUsed;
		public virtual event EventHandler<TokenUsed>? OnEachTokenUsed;

#pragma warning restore CS0067
	}
}